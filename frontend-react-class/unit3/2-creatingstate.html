Understanding State in React

React state lets your components hold and manage dynamic data over time.
Whenever state changes—by user interaction or data updates—the component
re-renders to reflect the new information.​

Types of Components
React supports two main types of components:

Class Components: Use the this.state object and this.setState() method.

Functional Components: Use the useState hook (and advanced hooks like useReducer).

Let's build from basics to more advanced examples.


*********************************************************
1. Class Component State (Basic)
jsx
import React from 'react';

class MyCar extends React.Component {
constructor(props) {
super(props);
this.state = {
brand: 'Ford',
year: 1964
};
}
render() {
return (
<div>
  <h1>Brand: {this.state.brand}</h1>
  <p>Year: {this.state.year}</p>
</div>
);
}
}
Key ideas:

State is an object created in the constructor.

Change state using this.setState() to trigger a re-render.

*************************************************************

2. State in Functional Components (Basic)
jsx
import React, { useState } from 'react';

function Counter() {
const [count, setCount] = useState(0);
return (
<div>
  <p>Count: {count}</p>
  <button onClick={()=> setCount(count + 1)}>Increment</button>
</div>
);
}
Key ideas:

useState gives you a state value and its updater function.

Call setCount(newValue) to change the state.
************************************************************************

3. Controlled Inputs (User-Driven State)
jsx
import React, { useState } from 'react';

function NameInput() {
const [name, setName] = useState('');
return (
<input value={name} onChange={e=> setName(e.target.value)} />
);
}
Why? This keeps input value in state, so your UI is always 'in sync.'

************************************************************************

4. Multiple State Variables
jsx
function CarInfo() {
const [brand, setBrand] = useState('Ford');
const [color, setColor] = useState('red');
return (
<div>
  <span>{brand} ({color})</span>
</div>
);
}
Tip: Use multiple state variables for independent bits of data.


************************************************************************
5. Advanced: Complex State with useReducer
When your state has complex logic or multiple, interrelated values,
useReducer centralizes updates:

jsx
import React, { useReducer } from 'react';

function reducer(state, action) {
switch (action.type) {
case 'increment':
return { ...state, count: state.count + 1 };
case 'reset':
return { ...state, count: 0 };
default:
return state;
}
}

function AdvancedCounter() {
const [state, dispatch] = useReducer(reducer, { count: 0 });
return (
<>
  <p>Count: {state.count}</p>
  <button onClick={()=> dispatch({ type: 'increment' })}>Increment</button>
  <button onClick={()=> dispatch({ type: 'reset' })}>Reset</button>
</>
);


************************************************************************
Key points:

Centralizes logic; good for forms/todos/wizards.

More maintainable for complex transitions.​

Summary & Mnemonic

State = internal data

With Class: this.state, this.setState()

With Function: useState or useReducer

State drives re-renders

For simple values, use useState. For next-step logic, try useReducer.

Mnemonic: 'STATE'
Stored safely

Triggers re-render

Always use updater

Toy examples help

Evolve with logic (useReducer for complexity)