React useEffect: From Basic to Advanced
The useEffect hook lets you run side effects—like fetching data,
 updating the DOM, or setting up subscriptions—directly within 
 your React functional components.

 It acts as a replacement for
 lifecycle methods like componentDidMount, componentDidUpdate, 
 and componentWillUnmount in class components.​

Basic Syntax
jsx
useEffect(() => {
  // side effect code
}, [dependencies]);
The function runs after every render by default.

The optional dependency array controls when the effect runs.​

1. Run Effect After Every Render
jsx
import { useEffect, useState } from 'react';

function EveryRender() {
  const [count, setCount] = useState(0);
  useEffect(() => {
    console.log('Effect ran!');
  }); // No dependencies!
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
The effect runs after every render, both initial and subsequent updates.​

2. Run Effect Only Once (Component Mount)
jsx
function MountOnce() {
  useEffect(() => {
    console.log('Component mounted!');
    // Fetch data or set up subscriptions here
  }, []); // Empty array means "just once"
  return <div>Hello</div>;
}
Runs only once after the initial render—like componentDidMount.​

3. Effect Runs When Specific State/Props Change
jsx
function WatchCount({ step }) {
  const [count, setCount] = useState(0);
  useEffect(() => {
    console.log(`Count or step changed! Count: ${count}, Step: ${step}`);
  }, [count, step]);
  return <button onClick={() => setCount(count + step)}>Add {step}</button>;
}
Only runs when count or step changes—like componentDidUpdate for the
 listed dependencies.​

4. Cleanup on Unmount (and Before Next Effect)
jsx
function Timer() {
  const [seconds, setSeconds] = useState(0);
  useEffect(() => {
    const interval = setInterval(() => setSeconds(s => s + 1), 1000);
    // Cleanup function: runs on unmount or before re-running the effect
    return () => clearInterval(interval);
  }, []); // Only once
  return <div>Seconds: {seconds}</div>;
}
Cleanup is critical for timers, subscriptions, or manual DOM work.​

5. Advanced Pattern: Fetching Data
jsx
function FetchUser({ userId }) {
  const [user, setUser] = useState(null);
  useEffect(() => {
    let cancelled = false;
    fetch(`/api/user/${userId}`)
      .then(res => res.json())
      .then(data => { if (!cancelled) setUser(data); });
    return () => { cancelled = true; };
  }, [userId]);
  if (!user) return <div>Loading...</div>;
  return <div>{user.name}</div>;
}
Runs when userId changes. Handles cleanup to avoid setting state after unmount.​

6. Conditional Effects
Run logic inside useEffect only if certain conditions are
 met (useful for complex flags or refs).

jsx
function ConditionalEffect({ track }) {
  const [count, setCount] = useState(0);
  useEffect(() => {
    if (track) {
      console.log('Tracking count:', count);
    }
  }, [count, track]);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
Summary
No dependencies: Runs after every render.

Empty array: Runs once on mount.

[x, y]: Runs on mount and whenever x or y changes.

Cleanup: Return a function to clean up subscriptions/timers.