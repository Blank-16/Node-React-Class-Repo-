React Hooks: Basics and Example
React Hooks are special functions that let you use React features—like state,
 lifecycle methods, and context—in function components, without needing to
  write classes. 
  
  Hooks were introduced in React 16.8.​

Why Hooks?
Simplify code: No need for class components when you want state or side effects.

Reuse logic: Easily share and extract stateful logic between components
 by making custom hooks.

Direct access to features: Use state, refs, context, and effects directly
 in your functions.

The Two Most Common Hooks
useState: Lets your function component hold local state 
(like a variable that survives re-renders).

useEffect: Lets you perform side effects (like fetching data,
 timers, or manual DOM changes) after rendering.

Basic useState Example
jsx
import { useState } from 'react';

function Counter() {
  // Declare a 'count' state variable, with initial value 0
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
Explanation:

useState(0) declares a state variable (count) with default value 0, 
and a function (setCount) to change it.​

When you click the button, setCount(count + 1) updates the state, 
causing the UI to re-render with the new value.

Rules for Using Hooks
Only call hooks at the top level (never inside loops, conditions,
 or nested functions).

Only call hooks in function components (or custom hooks)—never 
in regular JS functions or class components.​

How is This Different From Classes?
Hooks let you:

Avoid class syntax (this.state, constructor, etc.)

Write cleaner, more modular code

Share stateful logic (with custom hooks) instead of writing Higher
 Order Components or render props

Quick Recap
Hooks add state and features to function components.

Most common: useState (for state), useEffect (for side effects).

Always import hooks from React and follow the hook rules.